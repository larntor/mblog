---
layout: post
title:  win10 uwp MVVM 轻量框架 
category: uwp 
---

如果在开发过程，遇到多个页面之间，需要传输信息，那么可能遇到设计的问题。如果因为一个页面内包含多个子页面和多个子页面之间的通信问题找不到一个好的解决方法，那么请看本文。如果因为ViewModel代码越来越多烦恼，请试试本文提供的框架。

本文介绍我做的框架，这是一个轻量的框架，可以同时使用其它的框架，用于多个页面之间，多个 ViewModel 之间的通信。

<!--more-->
<!-- csdn -->

一般的通信是一个页面内存在多个子页面，而且经常需要对多个页面进行通信，为了降低多个页面的耦合度，于是我就做了自己的框架。这个框架比较简单，很多地方都抄袭了MVVMLight，所以是他的轻量版。

暂时我把框架放在 Nuget ，因为还没写文档，所以暂时不告诉大家地址啦。

## 多页面存在的问题

这里所说的页面包括用户控件，很多情况，可以使用用户控件代替页面。在存在一个页面创建之后，就不需要替换，那么使用用户控件也可以，但是页面的等级是比用户控件更高，所以在比较大的功能，建议使用页面。另一个是存在一个功能，需要替换多个页面，这时使用用户控件就不太好，建议使用页面。接下来，我将会分析两个情况来告诉大家。

![](http://7xqpl8.com1.z0.glb.clouddn.com/34fdad35-5dfe-a75b-2b4b-8c5e313038e2%2F2017730155441.jpg)

第一个情况如上图的设计，左侧的选项页面就是在程序运行中不会改变的，即使改变，也只是某一些选项，所以这个左侧页面，就可以尝试使用用户控件，或者连用户控件也不要，直接写就可以了。

第二个情况就是上图功能页面，在点击不同的选项，显示不同的页面，那么这时建议使用的就是Frame和页面，因为这样比较容易导航。虽然使用用户控件同样可以做到，并且加上 DataTemplate 也可以做出来。

假如左侧的页面和功能页面是两个不同的页面，那么这两个页面如何进行通信？简单的方法是，直接使用 MianPage 传给左侧页面一个 Frame ，于是左侧页面就可以通过 Frame 进行跳转到需要显示的功能页面。看起来这是一个不错的方法，但是如果有一天，需要把功能页面修改为用户控件，那么这个动作就会很大。当然，程序员是最大的，所以不会修改，好吧，我相信了。那么如果存在另一个按钮，用于跳转到某个特定的功能页面，这时怎么办？

如果说，那就让他跳，反正我不关心，这时需要想一下，左侧页面，是否对当前显示的页面做出不同的颜色，如果功能页面修改了，如何知道？

![](http://7xqpl8.com1.z0.glb.clouddn.com/34fdad35-5dfe-a75b-2b4b-8c5e313038e2%2F201773016113.jpg)

所以多页面通信之间还是有坑的，最好让他们耦合降低，这样就不会出现修改时，准备拿刀砍人。如果耦合很低，点击左侧页面，只是向一个类A发送信息，那么之后这个类A不会改变，那么左侧页面就不会进行修改，如果需要修改功能页面。如果这时有一个按钮可以控制功能页面，那么这个按钮同样对类A发送消息就可以，不需要去关心里面的逻辑，而功能页面通过监听类A的事件，可以绑定当前功能页面的对应列，所以这个设计是比刚才的方法比较好的。

接下来继续将一个多页面通信的问题。假如有一个程序，看起来和下面的图一样，有主页面，主页面有多个页面，那么这时，如何对这些页面进行通信？假如需要点击主页面的一个按钮，控制页面A中的元素，那么如何做？简单的方法是直接主页面知道页面A，直接对他元素修改。但是这个方法很容易看到，耦合很高，如果页面A修改了，那么这时就无法在不修改主页面继续运行。如果更复杂的项目，可能需要修改的地方就会很多，如果有新人不知道，没有修改所有的地方，很容易就出现软件的质量差。

![](http://7xqpl8.com1.z0.glb.clouddn.com/34fdad35-5dfe-a75b-2b4b-8c5e313038e2%2F2017730161636.jpg)

如果同样可以通过主页面向另一个类B发送信息，页面A监听类B，所以页面A就可以得到主页面需要删除元素的信息，由A页面来删除元素，这样可以做到耦合比较低。那么问题在很多情况都需要创建一个类来接收消息，而需要页面去获得消息，是否可以做出一个框架？我的框架就是这样想到，本来 MVVMLight 也有这样功能，看起来他的功能比较多，所以我就自己写一个，当然看完本文，相信大神们很容易就写出自己的框架。

## 通信

这个框架最好的地方在与解决多页面通信，解决方法是直接使用子页面对应的 ViewModel 向上一级页面对应的 ViewModel 发送信息，上一级的 ViewModel 接收到消息就可以判断这个消息是发送到同一级的 ViewModel 还是自己处理。

简单的方式如下所示，假如消息的类是 M ，当然，发送的消息可能很多类型，但是这里就使用 M 表示。而 AModel 就是子页面对应的 ViewModel ，BModel 就是上一级对应的 ViewModel ，那么根据上面的说法，使用 BModel 获得 AModel 的消息的代码很简单。

```
     class AModel
     {
           public Action<M> Send;
     }
     
     class BModel
     {
     
          public BModel()
          {
               AModel.Send+=Receive;
          }
          
          public AModel AModel{set;get;} = new AModel();
          
          public void Receive(M m)
          {
          
          }
     }
```

但是这个方法可以看到的是，接收到消息是在 BModel 处理，那么需要写很多代码用于判断当前是什么消息，然后还需要写很多代码进行处理，看起来就不是一个好的方法。能不能把处理给分开，答案相信你可以猜到了，如果不可以把处理分开，那么这个框架也就不好用了。

来创建一个类，这个类用于处理消息 M ，如果接收到消息 M ，就使用这个类来处理。于是处理的接收的函数就需要添加下面代码。

```
    
    public void Receive(M m)
    {
    	处理 处理 = new 处理();
    	处理.xx(m);
    }
```

但是只是输入了 m ，很多时候处理是需要修改 ViewModel ，或修改数据，如果数据有全局，那么修改比较简单，但是实际数据一般都是放在 ViewModel ，所以这时需要传入需要处理的 ViewModel 到对应的处理类。

假如有左右两个页面，左边的页面需要修改右边的页面，那么这时需要把上面的代码加上传入右边的 ViewModel ，所以处理类一般都需要传入。这样的做法可以让左边页面发送消息说，修改右边页面，而不需要让左边页面知道右边页面是什么，也不需要让他上一级页面知道右边页面是什么，上一级页面也不知道左边页面是什么，他知道的只有收到消息，找到消息发送到那个ViewModel，然后使用消息对应的处理。

可以看到一个消息可以对应多个处理，消息也对应了他需要发送到的 ViewModel ，于是上一级页面就可以根据消息找到消息需要发的 ViewModel 和找到对应处理，让他处理这个消息。这样本来 ViewModel 需要写很多代码在很多个处理类，所以需要的代码长度就没有那么长。
